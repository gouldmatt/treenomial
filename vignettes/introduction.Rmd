---
title: "Introduction to treenomial"
author: "Matthew Gould"
date: "09/07/2019"
output:
  html_document: default
  pdf_document: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Generating a coefficient matrix for a phylo object 
```
library(treenomial)
library(ape)
library(ggtree)

# A 6 tip rooted bifuricating tree 
exampleTree <- rtree(n = 6, rooted = TRUE, tip.label = 1:6)

# generate the coefficient matrix defining its polynomial 
coefficientMat <- coefficientMatrix(exampleTree)

exampleTree$edge.length <- FALSE

```

```{r message=FALSE, include=FALSE}
library(treenomial)
library(ape)
library(ggtree)
library(multipol)

# A 6 tip rooted bifuricating tree 
exampleTree <- rtree(n = 6, rooted = TRUE, tip.label = 1:6)

# generate the coefficient matrix defining its polynomial 
coefficientMat <- coefficientMatrix(exampleTree)

exampleTree$edge.length <- FALSE

coefficientMatChar <- as.character(as.multipol(t(coefficientMat)))

```

The resulting tree: 

```{r message=FALSE, warning=FALSE}
ggtree(exampleTree)
```

The coefficient matrix of the tree defining polynomial: 

```{r message=FALSE, warning=FALSE}
coefficientMat
coefficientMatChar
```

## Generating MDS plots from multiple coefficient matrices 

```{r message=FALSE}
library(treenomial)
library(apTreeshape)
# generate some forests
numTrees <- 100
numTips <- 400

pdaTrees <- rtreeshape(numTrees, tip.number = numTips, model = "pda")
yuleTrees <- rtreeshape(numTrees, tip.number = numTips, model = "yule")
aldousTrees <- rtreeshape(numTrees, tip.number = numTips, model = "aldous")
biasedTrees <- rtreeshape(numTrees, tip.number = numTips, model = "biased")

# place into a list
allTrees <- list(pdaTrees = pdaTrees, yuleTrees = yuleTrees, aldousTrees = aldousTrees, biasedTrees = biasedTrees)

# convert to phylo type
allTrees <- lapply(unlist(allTrees, recursive = FALSE), as.phylo)

# generate the coefficient matrices 
coeffMats <- coefficientMatrix(allTrees)
```

### Using  $\sum_{}{}\log_{}{(1+|a-b|)}$ distance on the coefficients 


```{r}
test <- coefficientMds(coefficientMatrices = coeffMats, dim = 3, title = "Coefficient MDS on different tree models", legendTitle = "tree model", method = "sumLogDiff")

htmltools::div( test, align="center" )
```

### Using the binary fager distance on the coefficients 
#### a: number of (TRUE, TRUE) pairs

#### b: number of (FALSE, TRUE) pairs

#### c: number of (TRUE, FALSE) pairs

#### d: number of (FALSE, FALSE) pairs

#### fager: $\frac{a}{\sqrt{(a+b)(a+c)}}-\frac{\sqrt{a+c}}{2}$



```{r}
test <- coefficientMds(coefficientMatrices = coeffMats, dim = 3, title = "Coefficient MDS on different tree models", legendTitle = "tree model", method = "fager")

htmltools::div( test, align="center" )
```


### 5 tip tree test 
```{r message=FALSE}
library(treenomial)
library(apTreeshape)
# generate some forests
numTrees <- 500
numTips <- 5

pdaTrees <- rtreeshape(numTrees, tip.number = numTips, model = "pda")
yuleTrees <- rtreeshape(numTrees, tip.number = numTips, model = "yule")
aldousTrees <- rtreeshape(numTrees, tip.number = numTips, model = "aldous")
biasedTrees <- rtreeshape(numTrees, tip.number = numTips, model = "biased")

# place into a list
allTrees <- list(pdaTrees = pdaTrees, yuleTrees = yuleTrees, aldousTrees = aldousTrees, biasedTrees = biasedTrees)

# convert to phylo type
allTrees <- lapply(unlist(allTrees, recursive = FALSE), as.phylo)

# generate the coefficient matrices 
coeffMats <- coefficientMatrix(allTrees)


test <- coefficientMds(coefficientMatrices = coeffMats, dim = 3, title = "5 tip trees fager", legendTitle = "tree model", method = "fager")
htmltools::div( test, align="center" )

test <- coefficientMds(coefficientMatrices = coeffMats, dim = 3, title = "5 tip trees sumLogDiff", legendTitle = "tree model", method = "sumLogDiff")

htmltools::div( test, align="center" )

```

### Complex Coefficients

```{r message=FALSE}
library(treenomial)
library(apTreeshape)
# generate some forests
numTrees <- 200
numTips <- 500

pdaTrees <- rtreeshape(numTrees, tip.number = numTips, model = "pda")
yuleTrees <- rtreeshape(numTrees, tip.number = numTips, model = "yule")
aldousTrees <- rtreeshape(numTrees, tip.number = numTips, model = "aldous")
biasedTrees <- rtreeshape(numTrees, tip.number = numTips, model = "biased")

# place into a list
allTrees <- list(pdaTrees = pdaTrees, yuleTrees = yuleTrees, aldousTrees = aldousTrees, biasedTrees = biasedTrees)

# convert to phylo type
allTrees <- lapply(unlist(allTrees, recursive = FALSE), as.phylo)

# generate the coefficient matrices 
coeffMats <- coefficientMatrix(allTrees, complex = TRUE)
```

```{r}
test <- coefficientMds(coefficientMatrices = coeffMats, dim = 3, title = "SumLogDiff on different tree models using complex", legendTitle = "tree model", method = "sumLogDiff")

htmltools::div( test, align="center" )
```


# R0 Estimation 

```{r message=FALSE, include=FALSE}
library(treenomial)
library(TreeSim)
library(ggtree)
#
# # pruning function
prunetosize <- function(tree,size) {
    nt=length(tree$tip.label)
    if (nt <= size) {return(tree)} else {
      todrop =sample(1:nt, nt-size);
      return(drop.tip(tree, todrop))
   }

 }

simbds=lapply(c(pi), function(x) sim.bd.taxa(n=500, numbsim=1,mu=1, lambda=x,complete = TRUE))
# # creates a list of 2 lists

 # R0=unlist(lapply(c(6), function(x) rep(x,100))) # R0 values (lambda/mu)

 psim=c(simbds[[1]]) # one list, rather than a list of 2 lists


 psim=lapply(psim, function(tree) prunetosize(tree,250)) # uniformly at random drop
 
 piTree <- psim[[1]]

```

```{r message=FALSE, warning=FALSE}
library(pracma)
approxR0 <- estimateR0(piTree, numStepSim = 100, start = 1.5, end = 8.5, step = 0.5, numTotalSim = 2)
median(approxR0)
std(approxR0)
```


