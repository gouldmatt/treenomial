---
title: "treenomial introduction"
author: "Mattthew Gould"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{treenomial_introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  cache = TRUE,
  comment = "#>",
  collapse = TRUE
)
```


This guide will take you through the main functionality within the package with some discussion on the main algorithms. See the references section for the detailed mathmatical paper and [here]() for the function reference. 

```{r loading_treenomial}
library(treenomial)
```

**Table of Contents**

- [Trees to Polynomials](#trees-to-polynomials)

- [Calculating distances](#calculating-distances)


- [References](#references)


<a name="trees-to-polynomials)"></a>

## Trees to Polynomials

The main core of the treenomial package is the unique representation of
trees with polynomials. Currently, an input tree must meet the following criteria to be 
represented with a polynomial in the package: two or zero
children for each node, no ordering to the nodes and one node chosen as
the root. Methods of comparison can be built using the familiar structure of polynomials that 
may be harder to obtain directly from the tree structure. 

Within the package all polynomials are described with
coefficient matrices where each element describes a coefficient of a
polynomial. 

<center>
An example coefficient matrix: 
</center>
$$
{P(x,y) = x^4 + 2x^2y + y^2 + y} \hspace{7pt} \Rightarrow \hspace{7pt}
\begin{array}{c c c c} &
\begin{array}{c c c c c} \hspace{2pt} 1 &  \hspace{0pt} x & \hspace{-1pt} x^2 & \hspace{-5pt} x^3 & \hspace{-6pt} x^4 \\
\end{array} 
\\
\begin{array}{c c c c c}
1 \hspace{-8pt}\\
y \hspace{-8pt}\\
y^2 \hspace{-10pt}
\end{array} 
&
\left(
\begin{array}{c c c c c}
0 & 0 & 0 & 0 & 1 \\
1 & 0 & 2 & 0 & 0 \\ 
1 & 0 & 0 & 0 & 0 
\end{array}
\right)
\end{array}
$$


A phylo object can be passed to the
*coefficientMatrix* function to recieve its coefficent matrix. Below is
a plot of a rooted unordered full binary tree and its unique
coefficient matrix. 

```{r single_tree_gen, fig.align='center'}
library(ape)

# a 6 tip rooted bifurcating tree 
exampleTree <- rtree(n = 6, rooted = TRUE)

# plot the tree 
plot.phylo(ladderize(exampleTree), use.edge.length = FALSE, show.tip.label = FALSE, direction = "downwards")
```

```{r coeff_mat_gen}
# generate the coefficient matrix
coeffMatrix(exampleTree)
```


<a name="calculating-distances"></a>

## Calculating distances

With the coefficient matrices from different trees one can use a
distance metric between the coefficient values to construct a distance
matrix. The default distance metric in "treenomial" between all
$a_{ij}$ and $b_{ij}$ elements of two matrices $A$,$B$ is:   
$$D(A,B) = \sum_{i,j}\log(1+|a_{ij} - b_{ij}|)$$

Here we generate trees using various models from the *apTreeshape*
package and use this "sumLogDiff" metric to construct a distance
matrix: 

```{r distance_mat_example}
library(apTreeshape)

# generate the model trees 
numTrees <- 1 
numTips <- 100

pdaTrees <- rtreeshape(numTrees, tip.number = numTips, model = "pda")
yuleTrees <- rtreeshape(numTrees, tip.number = numTips, model = "yule")
aldousTrees <- rtreeshape(numTrees, tip.number = numTips, model = "aldous")
biasedTrees <- rtreeshape(numTrees, tip.number = numTips, model = "biased")

# place into a list
allTrees <- c(pdaTrees, yuleTrees, aldousTrees, biasedTrees)
names(allTrees) <- rep(c("pdaTrees", "yuleTrees", "aldousTrees", "biasedTrees"), each = numTrees)

# generate the coefficient matrices 
coeffMats <- coeffMatrix(allTrees)

# generate the distance matrix 
# coeffDist(coeffMats, method = "logL1", progressBar = F)

```

With the distance matrix one could go about dimensionality reduction; here we use the cmdscale from the *stats* package along with the *plotly* package to create a interactive 3D MDS scatterplot of the tree models. 

```{r sumLogDiff_ex, cache = TRUE}
library(apTreeshape)
library(plotly)
library(stats)

# generate the model trees 
numTrees <- 30
numTips <- 500

pdaTrees <- rtreeshape(numTrees, tip.number = numTips, model = "pda")
yuleTrees <- rtreeshape(numTrees, tip.number = numTips, model = "yule")
aldousTrees <- rtreeshape(numTrees, tip.number = numTips, model = "aldous")
biasedTrees <- rtreeshape(numTrees, tip.number = numTips, model = "biased")

# place into a list
allTrees <- c(pdaTrees, yuleTrees, aldousTrees, biasedTrees)
names(allTrees) <- rep(c("pdaTrees", "yuleTrees", "aldousTrees", "biasedTrees"), each = numTrees)

# calculate the distace matrix 
distMat <- phyloDist(allTrees, method = "b", progressBar = T)

# perform MDS and plot 
fit <- cmdscale(distMat, k = 3)

mdsRes <- data.frame(fit, "color" = names(allTrees))
sumLogDiffPlot <- plot_ly(mdsRes, x = mdsRes$X1, y = mdsRes$X2, z = mdsRes$X3, color = mdsRes$color, type = "scatter3d", size = 2, mode = "markers", showlegend = TRUE)

```

```{r sumLogDiff_print, echo=FALSE, cache=T}
library(plotly)
htmltools::div( config(sumLogDiffPlot,displayModeBar = F), align="center" )
```

The function *distPlot()* is also provided to plot the minimum or maximum distance tree from a target tree in the distance matrix. 

```{r test, cache = TRUE, fig.align='center'}
# add our "test" target tree to the list 
# allTrees[["test"]] <-  rtree(150)
 
# recompute the distance matrix 
# distMat <- phyloDist(allTrees)

# find and plot the minimum distance tree from the target tree in the distance matrix from above 
# phyloDistPlot(trees = allTrees, distMatrix = distMat, target = "test", comparison = "min", plotFacing = T)
```

```{r, cache = TRUE, fig.align='center'}
# find and plot the maximum distance tree from the target tree in the distance matrix from above 
# phyloDistPlot(trees = allTrees, distMatrix = distMat, target = "test", comparison = "max", plotFacing = T)
```


# binary intpretation of coefficients 



# allbinaryTreeShapes 

link to wad num on 

```{r message=FALSE, fig.align='center'}

allBinSix <- allBinaryTreeShapes(9, type = "phylo")[[9]]
par(mfrow=c(7,7))
par(mar=c(1,1,1,1))
all8TipPlots <- lapply(allBinSix, function(t) plot.phylo(ladderize(t), direction = "downwards", show.tip.label = FALSE))



```


# wedge 


<!-- • 2) distances on the coefficients (logL1 etc ....) -->


<!-- complex coefficient matrices  -->

<!-- • 3) model trees to mds plot -->

<!-- • 4) wedge and alltrees space -->








